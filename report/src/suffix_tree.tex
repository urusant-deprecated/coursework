\section{Нахождение попарной похожести текстов}

\subsection{Понятие об аннотированном суффиксном дереве}
Чтобы определить аннотированное суффиксное дерево, определим сначала более общее понятие \emph{бора}. Итак, \emph{бор} - это структура данных для хранения набора строк, представляющая собой корневой дерево, каждому ребру которого соответствует некоторый символ. При этом некоторые вершины помечены как \emph{терминальные}. Каждой вершине ставится в соответствие строка как последовательность символов, написанных на ребрах между корнем и этой вершиной. Говорят, что бор \emph{принимает} строку $s$, если есть такая терминальная вершина, которой соответствует строка $s$.\newline
Приведем пример. Пусть у нас есть набор строк, например, A = \{"гол"\,, "горн"\,, "гик"\,, "пик"\}. Для него бор будет выглядеть следующим образом:
\begin{center} 
	\includegraphics[width=10cm]{img/trie}
\end{center}
Здесь для удобства все вершины пронумерованы, а терминальные отмечены красным цветом.\newline
Тогда, например, вершине 10 соответствует строка "горн"\,, поскольку последовательность ребер от корня до нее выглядит как $0 \rightarrow 1, 1 \rightarrow 3, 3 \rightarrow 6, 6 \rightarrow 10$, и ей соответствует последовательность символов "горн". \newline
Заметим, что в текущем определении есть некоторая неоднозначность. Действительно, например, следующее дерево также удовлетворяет всем условиям:
\begin{center} 
	\includegraphics[width=10cm]{img/trie2}
\end{center}
Чтобы избежать этого, потребуем дополнительно, чтобы для каждой вершины $v$ и символа $c$ было не более одного ребра из $v$ в какого-нибудь из ее потомков, соответствующего символу $c$. Кроме того, потребуем, чтобы все листья были терминальными вершинами, то есть соответствовали какой-нибудь строке из множества (иначе дерево может быть сколь угодно большим). Тогда для любого множества строк бор определяется однозначно. Действительно, пусть есть 2 различных бора для одного и того же множества строк. Найдем ребро, которое есть в одном, но нету во втором, причем если таких несколько, то выберем то, которое ближе всех к корню. Пусть это ребро $v \rightarrow to$, ему соответствует символ $c$, а вершине $v$ - строка $s$. Поскольку каждый лист - терминальная вершина, какой-то потомок $to$ - терминальная вершина, значит, в множестве строк есть какая-то строка $S$ с префиксом $s + c$. С другой стороны, если мы пойдем от корня по строке $s$ во втором дереве (то есть сначала пойдем по ребру, которому соответствует символ $s_0$, потом - $s_1$, и так далее), то мы, очевидно, придем в ту же вершину $v$. Однако, мы не сможем пойти дальше по символу $c$ по предположению, значит, второй бор не может принимать строку с префиксом $s + c$. Таким образом, мы пришли к противоречию, и тем самым доказали, что бор по множеству строк определяется однозначно. Кроме того, доказательство показывает способ построения этого бора. Пусть изначально бор пустой, то есть состоит из 1й вершины - корня. Будем последовательно добавлять в него строки следующим образом: будем идти по имеющемуся дереву в соответствии с очередной строкой $s$, и если в какой-то момент не находим нужного ребра, то просто создаем новое ребро, ведущее из текущей вершины в новую и соответствующее нужному нам символу. В конце помечаем вершину, в которой оказались, терминальной. Очевидно, этот алгоритм не может добавить 2 ребра с одним и тем же символом из одной вершины, потому что мы создаем ребро, только если его еще нет, и каждый лист будет терминальным, потому что каждая вершина соответствует некоторому префиксу какой-то из строк множества, значит, у каждой вершины есть терминальный потомок. \newline
Пусть теперь у нас есть некоторый текст, который мы будем рассматривать как некоторый набор слов. \emph{Суффиксным деревом} для этого текста назовем бор, который принимает суффиксы всех слов и только их. \newline
Снова приведем пример. Пусть есть, например, текст, состоящий из 2х слов "голод"\ и "холод". Тогда суффиксное дерево должно принимать все суффиксы этих двух слов, то есть строки "голод"\,, "олод"\,, "лод"\,, "од"\,, "д"\,, "холод". Построим бор на этих строках по выше приведенному алгоритму:
\begin{center} 
	\includegraphics[width=10cm]{img/suffix_tree}
\end{center}

Теперь введем понятие \emph{аннотированного суффиксного дерева}. Аннотированное суффиксное дерево для набора строк - это суффиксное дерево, в котором для каждой вершины дополнительно хранится целое число (частота) - количество строк из набора, префиксом которых является строка, соответствующая этой вершине. Заметим, что это не всегда совпадает с количеством терминальных вершин в поддереве, поскольку в наборе каждая из строк может встречаться несколько раз. \newline
Например, для суффиксного дерева, которое было построено ранее, аннотированное суффиксное дерево будет выглядеть следующим образом:
\begin{center} 
	\includegraphics[width=10cm]{img/annotated_suffix_tree}
\end{center}
Так, в этом примере суффиксы "олод"\,, "лод"\,, "од"\,, "д"\ учитывыются по 2 раза. \newline
Отметим, алгоритм, приведенный выше для построения суффиксного дерева легко модифицировать для подсчета частот. Действительно, при добавлении очередного суффикса в дерево значения частот в вершинах пути от корня к вершине, отвечающей за этот суффикс, увеличиваются на 1, а в остальных - не изменяются. Поэтому можно просто добавлять 1 к частоте каждой вершины, которую проходим. У только что созданных вершин это значение должно быть равным 0, поскольку мы еще ни разу не проходили эту вершину.\newline
\subsection{Нахождение величины похожести текстов на основе суффиксных деревьев}
Пусть есть 2 текста $A, B$. Построим по ним аннотированные суффиксные деревья $S_A, S_B$. Далее найдем для этих суффиксных деревьев \emph{общее поддерево} $S$, то есть такое подмножество вершин, которые есть в обоих деревьях. При этом в качестве частот в $S$ будем использовать $f(a, b)$, где $a, b$ - частоты вершины в $S_A, S_B$, а $f$ - некоторая функция. Теперь остается оценить это дерево. В качестве оценки используем величину $\sum\limits_v \frac{frequency(v)}{frequency(p(v))}$, где $frequency(v)$ - частота вершины, а $p(v)$ - предок вершины v. Таким образом, мы суммируем по всем вершинам их условную вероятность появления в тексте, то есть вероятность перехода в вершину $v$ при условии, что мы уже дошли до $p(v)$. \newline
Рассмотрим, например, 2 текста A = \{"голод"\,, "холод"\}, B = \{"солод"\,, "вол"\}. Для $A$ мы уже строили дерево выше, для $B$ оно выглядит следующим образом:
\begin{center} 
	\includegraphics[width=10cm]{img/suffix_tree2}
\end{center}
Тогда общее поддерево имеет следующий вид:
\begin{center} 
	\includegraphics[width=10cm]{img/common_suffix_tree}
\end{center}
Пусть $f(a, b) = \frac{a + b}{2}$. Тогда оценка похожести равна:
$$ \frac{f(3, 4)}{f(8, 10)} + \frac{f(1, 2)}{f(8, 10)} + \frac{f(2, 2)}{f(8, 10)} + \frac{f(1, 2)}{f(3, 4)} + \frac{f(2, 2)}{f(3, 4)} + \frac{f(1, 2)}{f(2, 2)} + \frac{f(1, 2)}{f(2, 2)} + \frac{f(1, 2)}{f(1, 2)} + \frac{f(1, 2)}{f(1, 2)} = $$
$$\frac{3 + 4}{8 + 10} + \frac{1 + 2}{8 + 10} + \frac{2 + 2}{8 + 10} + \frac{1 + 2}{3 + 4} + \frac{2 + 2}{3 + 4} + \frac{1 + 2}{2 + 2} + \frac{1 + 2}{2 + 2} + \frac{1 + 2}{1 + 2} + \frac{1 + 2}{1 + 2} = 5.27778$$
\subsection{Параметризация}
Как можно заметить, данный алгоритм нахождения похожести принимает один дополнительный параметр, а именно, функцию $f(a, b)$. В данной работе были использованы следующие функции:
\begin{itemize}
\item $f(a, b) = \frac{a + b}{2}$
\item $f(a, b) = min(a, b)$
\item $f(a, b) = max(a, b)$
\item $f(a, b) = \sqrt{ab}$
\end{itemize}